// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kalido.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Kalido.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - KALKalidoRoot

@implementation KALKalidoRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - KALKalidoRoot_FileDescriptor

static GPBFileDescriptor *KALKalidoRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"Kalido"
                                                 objcPrefix:@"KAL"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - KALAuth

@implementation KALAuth

@dynamic userId;
@dynamic token;

typedef struct KALAuth__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
  int64_t userId;
} KALAuth__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = KALAuth_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(KALAuth__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = KALAuth_FieldNumber_Token,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(KALAuth__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[KALAuth class]
                                     rootClass:[KALKalidoRoot class]
                                          file:KALKalidoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(KALAuth__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - KALFetchOptions

@implementation KALFetchOptions

@dynamic hasAuth, auth;
@dynamic offset;
@dynamic limit;

typedef struct KALFetchOptions__storage_ {
  uint32_t _has_storage_[1];
  int32_t offset;
  int32_t limit;
  KALAuth *auth;
} KALFetchOptions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "auth",
        .dataTypeSpecific.className = GPBStringifySymbol(KALAuth),
        .number = KALFetchOptions_FieldNumber_Auth,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(KALFetchOptions__storage_, auth),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "offset",
        .dataTypeSpecific.className = NULL,
        .number = KALFetchOptions_FieldNumber_Offset,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(KALFetchOptions__storage_, offset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "limit",
        .dataTypeSpecific.className = NULL,
        .number = KALFetchOptions_FieldNumber_Limit,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(KALFetchOptions__storage_, limit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[KALFetchOptions class]
                                     rootClass:[KALKalidoRoot class]
                                          file:KALKalidoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(KALFetchOptions__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - KALError

@implementation KALError

@dynamic message;

typedef struct KALError__storage_ {
  uint32_t _has_storage_[1];
  NSString *message;
} KALError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "message",
        .dataTypeSpecific.className = NULL,
        .number = KALError_FieldNumber_Message,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(KALError__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[KALError class]
                                     rootClass:[KALKalidoRoot class]
                                          file:KALKalidoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(KALError__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - KALNearby

@implementation KALNearby

@dynamic hasError, error;
@dynamic id_p;
@dynamic t;
@dynamic fn;
@dynamic ln;
@dynamic img;
@dynamic l;
@dynamic f;
@dynamic k;
@dynamic b;
@dynamic bt;
@dynamic bl;
@dynamic blt;
@dynamic mt;
@dynamic hcc;
@dynamic aowc;
@dynamic ib;
@dynamic uf;
@dynamic ls;
@dynamic cfn;
@dynamic cln;

typedef struct KALNearby__storage_ {
  uint32_t _has_storage_[1];
  KALNearby_UserType t;
  NSString *fn;
  NSString *ln;
  NSString *img;
  NSString *l;
  NSString *mt;
  NSString *ls;
  NSString *cfn;
  NSString *cln;
  KALError *error;
  int64_t id_p;
  int64_t f;
  int64_t k;
  int64_t bt;
  int64_t blt;
  int64_t uf;
} KALNearby__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = KALNearby_FieldNumber_Id_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(KALNearby__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "t",
        .dataTypeSpecific.enumDescFunc = KALNearby_UserType_EnumDescriptor,
        .number = KALNearby_FieldNumber_T,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(KALNearby__storage_, t),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "fn",
        .dataTypeSpecific.className = NULL,
        .number = KALNearby_FieldNumber_Fn,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(KALNearby__storage_, fn),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ln",
        .dataTypeSpecific.className = NULL,
        .number = KALNearby_FieldNumber_Ln,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(KALNearby__storage_, ln),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "img",
        .dataTypeSpecific.className = NULL,
        .number = KALNearby_FieldNumber_Img,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(KALNearby__storage_, img),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "l",
        .dataTypeSpecific.className = NULL,
        .number = KALNearby_FieldNumber_L,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(KALNearby__storage_, l),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "f",
        .dataTypeSpecific.className = NULL,
        .number = KALNearby_FieldNumber_F,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(KALNearby__storage_, f),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "k",
        .dataTypeSpecific.className = NULL,
        .number = KALNearby_FieldNumber_K,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(KALNearby__storage_, k),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "b",
        .dataTypeSpecific.className = NULL,
        .number = KALNearby_FieldNumber_B,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "bt",
        .dataTypeSpecific.className = NULL,
        .number = KALNearby_FieldNumber_Bt,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(KALNearby__storage_, bt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "bl",
        .dataTypeSpecific.className = NULL,
        .number = KALNearby_FieldNumber_Bl,
        .hasIndex = 12,
        .offset = 13,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "blt",
        .dataTypeSpecific.className = NULL,
        .number = KALNearby_FieldNumber_Blt,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(KALNearby__storage_, blt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "mt",
        .dataTypeSpecific.className = NULL,
        .number = KALNearby_FieldNumber_Mt,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(KALNearby__storage_, mt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hcc",
        .dataTypeSpecific.className = NULL,
        .number = KALNearby_FieldNumber_Hcc,
        .hasIndex = 16,
        .offset = 17,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "aowc",
        .dataTypeSpecific.className = NULL,
        .number = KALNearby_FieldNumber_Aowc,
        .hasIndex = 18,
        .offset = 19,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "ib",
        .dataTypeSpecific.className = NULL,
        .number = KALNearby_FieldNumber_Ib,
        .hasIndex = 20,
        .offset = 21,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "uf",
        .dataTypeSpecific.className = NULL,
        .number = KALNearby_FieldNumber_Uf,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(KALNearby__storage_, uf),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "ls",
        .dataTypeSpecific.className = NULL,
        .number = KALNearby_FieldNumber_Ls,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(KALNearby__storage_, ls),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cfn",
        .dataTypeSpecific.className = NULL,
        .number = KALNearby_FieldNumber_Cfn,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(KALNearby__storage_, cfn),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cln",
        .dataTypeSpecific.className = NULL,
        .number = KALNearby_FieldNumber_Cln,
        .hasIndex = 25,
        .offset = (uint32_t)offsetof(KALNearby__storage_, cln),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "error",
        .dataTypeSpecific.className = GPBStringifySymbol(KALError),
        .number = KALNearby_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(KALNearby__storage_, error),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[KALNearby class]
                                     rootClass:[KALKalidoRoot class]
                                          file:KALKalidoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(KALNearby__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t KALNearby_T_RawValue(KALNearby *message) {
  GPBDescriptor *descriptor = [KALNearby descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:KALNearby_FieldNumber_T];
  return GPBGetMessageInt32Field(message, field);
}

void SetKALNearby_T_RawValue(KALNearby *message, int32_t value) {
  GPBDescriptor *descriptor = [KALNearby descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:KALNearby_FieldNumber_T];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum KALNearby_UserType

GPBEnumDescriptor *KALNearby_UserType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Phone\000Kalido\000OneWay\000Prompt\000Match\000User\000De"
        "leted\000";
    static const int32_t values[] = {
        KALNearby_UserType_Phone,
        KALNearby_UserType_Kalido,
        KALNearby_UserType_OneWay,
        KALNearby_UserType_Prompt,
        KALNearby_UserType_Match,
        KALNearby_UserType_User,
        KALNearby_UserType_Deleted,
    };
    static const char *extraTextFormatInfo = "\007\000%\000\001&\000\002&\000\003&\000\004%\000\005$\000\006\'\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(KALNearby_UserType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:KALNearby_UserType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL KALNearby_UserType_IsValidValue(int32_t value__) {
  switch (value__) {
    case KALNearby_UserType_Phone:
    case KALNearby_UserType_Kalido:
    case KALNearby_UserType_OneWay:
    case KALNearby_UserType_Prompt:
    case KALNearby_UserType_Match:
    case KALNearby_UserType_User:
    case KALNearby_UserType_Deleted:
      return YES;
    default:
      return NO;
  }
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
